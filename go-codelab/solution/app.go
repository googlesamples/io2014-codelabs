//  Package todo is an App Engine app providing a REST API to manage todo
//  lists.
//
//  The REST API provides the following handlers:
//
//  /api/auth GET
//    Current authentication state for the user requesting.
//
//  /api/lists GET
//    Gets all the list names and ids and creators if no user is logged in.
//    If the user is logged in, only their lists.
//  /api/lists POST [auth required]
//    Creates a new list.
//  /api/list/{list} GET
//    Gets the name, creator, and id of a list with id {list}.
//  /api/list/{list} DELETE [auth required]
//    Deletes the list with id {list}.
//
//  /api/lists/{list}/tasks GET
//    Lists all the tasks in the list with id {list}.
//  /api/lists/{list}/tasks POST [auth required]
//    Adds the task sent as POST data in the list with id {list}.
//  /api/lists/{list}/tasks/{task} UPDATE [auth required]
//    Updates the task with {task} in the list with id {list} with the task
//    sent as POST data.
//
package todo

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"

	"appengine"
	"appengine/datastore"
	"appengine/user"
)

const (
	// datastore entity kind to identify users.
	userKind = "User"
	// datastore entity kind for List
	listKind = "List"
	// datastore entity kind for Task
	taskKind = "Task"
)

// List represents a lists of tasks.
type List struct {
	// Autogenerated id, not stored in the datastore.
	ID string `datastore:"-"`

	Name    string // Name of the list
	Creator string // Email of the user that created this list
}

// Task represents an task in a todo list.
type Task struct {
	// Autogenerated id, not stored in the datastore.
	ID int64 `datastore:"-"`

	Text string // Text describing the task
	Done bool   // Completion state of the task.
	Time int64  // UnixTime used to sort the tasks chronologically.
}

func init() {
	// Register all the handlers.
	r := mux.NewRouter().PathPrefix("/api/").Subrouter()

	// Authentication data.
	r.Handle("/auth", appHandler(authHandler)).Methods("GET")

	// List management
	r.Handle("/list", appHandler(getAllLists)).Methods("GET")
	r.Handle("/list", authReq(createList)).Methods("POST")
	r.Handle("/list/{list}", appHandler(getList)).Methods("GET")
	r.Handle("/list/{list}", authReq(deleteList)).Methods("DELETE")

	// Task management.
	r.Handle("/list/{list}/task", appHandler(getTasks)).Methods("GET")
	r.Handle("/list/{list}/task", authReq(createTask)).Methods("POST")
	r.Handle("/list/{list}/task/{task}", authReq(updateTask)).Methods("PATCH")

	http.Handle("/api/", r)
}

// authHandler encodes the current user email and the urls to log in and out as
// a JSON object in the http response.
func authHandler(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)
	login, err := user.LoginURL(c, "/")
	if err != nil {
		return err
	}
	logout, err := user.LogoutURL(c, "/")
	if err != nil {
		return err
	}
	reply := struct{ User, Login, Logout string }{
		Login:  login,
		Logout: logout,
	}
	if u := user.Current(c); u != nil {
		reply.User = u.Email
	}
	return json.NewEncoder(w).Encode(reply)
}

// getAllLists fetches all the lists of the logged in user and encodes them
// in JSON format into the http response.
// If no user is logged in all lists are returned instead.
func getAllLists(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	query := datastore.NewQuery(listKind)
	// If the user is logged in fetch only their lists.
	if u := user.Current(c); u != nil {
		userKey := datastore.NewKey(c, userKind, u.Email, 0, nil)
		query = query.Ancestor(userKey)
	}

	lists := []List{}
	keys, err := query.GetAll(c, &lists)
	if err != nil {
		return fmt.Errorf("fetch all lists: %v", err)
	}

	// Update the encoded keys and encode the lists.
	for i, k := range keys {
		lists[i].ID = k.Encode()
	}
	return json.NewEncoder(w).Encode(lists)
}

// createList creates a new list. It reads a JSON encoded list from the request
// body and checks that the user is logged in.
func createList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode a list from the request body.
	list := List{}
	err := json.NewDecoder(r.Body).Decode(&list)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "decode list: %v", err)
	}
	list.Creator = user.Current(c).Email

	// Put the List in the datastore.
	userKey := datastore.NewKey(c, userKind, list.Creator, 0, nil)
	key := datastore.NewIncompleteKey(c, listKind, userKey)
	key, err = datastore.Put(c, key, &list)
	if err != nil {
		return fmt.Errorf("create list: %v", err)
	}

	// Update the encoded key and encode the list.
	list.ID = key.Encode()
	return json.NewEncoder(w).Encode(list)
}

// getList fetches the list with the id given in the url and encodes it in
// JSON format into the http response.
func getList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list id from the URL.
	id := mux.Vars(r)["list"]

	// Decode the obtained id into a datastore key.
	key, err := datastore.DecodeKey(id)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch the list from the datastore.
	list := &List{}
	err = datastore.Get(c, key, list)
	if err == datastore.ErrNoSuchEntity {
		return appErrorf(http.StatusNotFound, "list not found")
	}
	if err != nil {
		return fmt.Errorf("fetch list: %v", err)
	}

	// Set the ID field with the id from the request url and encode the list.
	list.ID = id
	return json.NewEncoder(w).Encode(&list)
}

// decode decodes a key from the given list id and finds the email of the creator
// of the list, which corresponds to the StringID of the ancestor key.
func decode(listID string) (list *datastore.Key, email string, err error) {
	// Decode the obtained id into a datastore key.
	list, err = datastore.DecodeKey(listID)
	if err != nil {
		return nil, "", appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Check that the logged in user is the creator of the list.
	user := list.Parent()
	if user == nil {
		return nil, "", appErrorf(http.StatusBadRequest, "list missing parent")
	}
	return list, user.StringID(), nil
}

// deleteList deletes the list with the id given in the url if the user is
// logged in and is the creator of the list.
func deleteList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	key, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	// Delete all tasks in the list and the list itself in a transaction.
	return datastore.RunInTransaction(c, func(c appengine.Context) error {
		// Find all the tasks in the list.
		taskKeys, err := datastore.NewQuery(taskKind).
			Ancestor(key).KeysOnly().GetAll(c, nil)
		if err != nil {
			return fmt.Errorf("get all tasks in list: %v", err)
		}

		// Delete all the tasks in the list.
		err = datastore.DeleteMulti(c, taskKeys)
		if err != nil {
			return fmt.Errorf("delete all tasks in list: %v", err)
		}

		// Delete the list itself.
		return datastore.Delete(c, key)
	}, nil)
}

// getTasks fetches all the tasks in the list with the id given in the url and
// encodes them in JSON format into the http response.
func getTasks(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list key from the url and decode it.
	listKey, err := datastore.DecodeKey(mux.Vars(r)["list"])
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch all the tasks from datastore.
	tasks := []Task{}
	keys, err := datastore.NewQuery(taskKind).Ancestor(listKey).GetAll(c, &tasks)
	if err != nil {
		return fmt.Errorf("fetch tasks: %v", err)
	}

	// Update the encoded keys and encode the tasks.
	for i, key := range keys {
		tasks[i].ID = key.IntID()
	}
	return json.NewEncoder(w).Encode(tasks)
}

// createTask parses a task from the request body in JSON format and adds it to
// the list with the id given in the url. Finally it encodes the created task
// with the generated id into the http response.
func createTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	// Decode the task from the request body.
	task := Task{}
	err = json.NewDecoder(r.Body).Decode(&task)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "decode task: %v", err)
	}
	if task.Text == "" {
		return appErrorf(http.StatusBadRequest, "missing task text")
	}

	// Set the creation time in the task and put it in the datastore.
	task.Time = time.Now().Unix()
	key := datastore.NewIncompleteKey(c, taskKind, listKey)
	key, err = datastore.Put(c, key, &task)
	if err != nil {
		return fmt.Errorf("add task: %v", err)
	}

	// Add the encoded key before encoding the task to JSON.
	task.ID = key.IntID()
	return json.NewEncoder(w).Encode(task)
}

// updateTask parses a task from the request body in JSON format and updates
// the task identified by the url in the datastore.
func updateTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	taskID, err := strconv.ParseInt(mux.Vars(r)["task"], 10, 64)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid task id")
	}

	task := Task{}
	if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
		return appErrorf(http.StatusBadRequest, "decode task: %v", err)
	}

	// Check if the Task exists already and fail if it doesn't.
	oldTask := Task{}
	key := datastore.NewKey(c, taskKind, "", taskID, listKey)
	err = datastore.Get(c, key, &oldTask)
	if err == datastore.ErrNoSuchEntity {
		return appErrorf(http.StatusNotFound, "task not found")
	}
	if err != nil {
		return fmt.Errorf("fetch task: %v", err)
	}

	// We update only the Done field, ignoring anything else.
	oldTask.Done = task.Done

	_, err = datastore.Put(c, key, &oldTask)
	return err
}
